/*
 * dofusdude
 *
 * # Open Ankama Developer Community The all-in-one toolbelt for your next Ankama related project.  ## Versions - [Dofus 2](https://docs.dofusdu.de/dofus2/) - [Dofus 3](https://docs.dofusdu.de/dofus3/)   - v1 [latest] (you are here)   ## Client SDKs - [Javascript](https://github.com/dofusdude/dofusdude-js) `npm i dofusdude-js --save` - [Typescript](https://github.com/dofusdude/dofusdude-ts) `npm i dofusdude-ts --save` - [Go](https://github.com/dofusdude/dodugo) `go get -u github.com/dofusdude/dodugo` - [Python](https://github.com/dofusdude/dofusdude-py) `pip install dofusdude` - [Java](https://github.com/dofusdude/dofusdude-java) Maven with GitHub packages setup  Everything, including this site, is generated out of the [Docs Repo](https://github.com/dofusdude/api-docs). Consider it the Single Source of Truth. If there is a problem with the SDKs, create an issue there.  Your favorite language is missing? Please let me know!  # Main Features - ü•∑ **Seamless Auto-Update** load data in the background when a new Dofus version is released and serving it within 10 minutes with atomic data source switching. No downtime and no effects for the user, just always up-to-date.  - ‚ö° **Blazingly Fast** all data in-memory, aggressive caching over short time spans, HTTP/2 multiplexing, written in Go, optimized for low latency, hosted on bare metal in üá©üá™.  - üì® **Almanax Discord Integration** Use the endpoints as a dev or the official [Web Client](https://discord.dofusdude.com) as a user.  - ü©∏ **Dofus 3 Beta** from stable to bleeding edge by replacing /dofus3 with /dofus3beta.  - üó£Ô∏è **Multilingual** supporting _en_, _fr_, _es_, _pt_, _de_.  - üß† **Search by Relevance** allowing typos in name and description, handled by language specific text analysis and indexing.  - üïµÔ∏è **Official Sources** generated from actual data from the game.  ... and much more on the Roadmap on my [Discord](https://discord.gg/3EtHskZD8h). 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: stelzo@steado.de
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`get_almanax_date`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAlmanaxDateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_almanax_range`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAlmanaxRangeError {
    UnknownValue(serde_json::Value),
}


/// Get a single date. There are not more details in the returned object than the normal range endpoint.
pub async fn get_almanax_date(configuration: &configuration::Configuration, language: &str, date: String, level: Option<i32>) -> Result<models::Almanax, Error<GetAlmanaxDateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_language = language;
    let p_path_date = date;
    let p_query_level = level;

    let uri_str = format!("{}/dofus3/v1/{language}/almanax/{date}", configuration.base_path, language=crate::apis::urlencode(p_path_language), date=p_path_date);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_level {
        req_builder = req_builder.query(&[("level", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Almanax`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Almanax`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAlmanaxDateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a range of dates, defaults to today + 6 following days but can specified by the query parameters.   filter[bonus_type] can be used seperately and does not have an effect on the other parameters.  range[from] changes the start date, everything else defaults to 6 following dates from this start date.  range[to] when used without anything else, it will use today as start date and this parameter as end. All ranges are inclusive.  range[from] + range[to] = inclusive range over the specified dates, should never be farther apart than 35 days.  range[from|to] + range[size] no need to specify the date, just following days with [from] (0 is today) or go backwards in time with only [to] and [size].  Not all combinations are listed but this should give you an idea how to they could work.
pub async fn get_almanax_range(configuration: &configuration::Configuration, language: &str, filter_left_square_bracket_bonus_type_right_square_bracket: Option<&str>, range_left_square_bracket_from_right_square_bracket: Option<String>, range_left_square_bracket_to_right_square_bracket: Option<String>, range_left_square_bracket_size_right_square_bracket: Option<i32>, timezone: Option<&str>, level: Option<i32>) -> Result<Vec<models::Almanax>, Error<GetAlmanaxRangeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_language = language;
    let p_query_filter_left_square_bracket_bonus_type_right_square_bracket = filter_left_square_bracket_bonus_type_right_square_bracket;
    let p_query_range_left_square_bracket_from_right_square_bracket = range_left_square_bracket_from_right_square_bracket;
    let p_query_range_left_square_bracket_to_right_square_bracket = range_left_square_bracket_to_right_square_bracket;
    let p_query_range_left_square_bracket_size_right_square_bracket = range_left_square_bracket_size_right_square_bracket;
    let p_query_timezone = timezone;
    let p_query_level = level;

    let uri_str = format!("{}/dofus3/v1/{language}/almanax", configuration.base_path, language=crate::apis::urlencode(p_path_language));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_filter_left_square_bracket_bonus_type_right_square_bracket {
        req_builder = req_builder.query(&[("filter[bonus_type]", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_range_left_square_bracket_from_right_square_bracket {
        req_builder = req_builder.query(&[("range[from]", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_range_left_square_bracket_to_right_square_bracket {
        req_builder = req_builder.query(&[("range[to]", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_range_left_square_bracket_size_right_square_bracket {
        req_builder = req_builder.query(&[("range[size]", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_timezone {
        req_builder = req_builder.query(&[("timezone", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_level {
        req_builder = req_builder.query(&[("level", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Almanax&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Almanax&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAlmanaxRangeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

